<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PARALEL VR</title>
  <style>
    body { margin: 0; background: #111; }
    html, body { height: 300vh; }
    canvas { display: block; position: fixed; top: 0; left: 0; }
  </style>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
  }
}
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

  // -------------------------------------------------
  // ESCENA BÁSICA
  // -------------------------------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111); // gris muy oscuro, no negro puro

  // Cámara: más largo far plane porque viajamos bastante en -Z
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
  camera.position.set(0, 2, 12); // arranque
  camera.lookAt(0, 2, 0);

  // Luz suave hemisférica (no crítica, pero ayuda a GLBs con materiales)
  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  light.position.set(0, 10, 0);
  scene.add(light);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // -------------------------------------------------
  // PISO Y TECHO CUADRICULADOS
  // -------------------------------------------------
  const gridOpacity = 0.15;
  const gridSize = 500;
  const gridDivs = 100;

  const gridFloor = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridFloor.material.opacity = gridOpacity;
  gridFloor.material.transparent = true;
  scene.add(gridFloor);

  const gridCeiling = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridCeiling.material.opacity = gridOpacity;
  gridCeiling.material.transparent = true;
  gridCeiling.position.y = 4;        // altura del “techo”
  gridCeiling.rotation.x = Math.PI;  // voltear para que la cara visible mire hacia abajo
  scene.add(gridCeiling);

  // -------------------------------------------------
  // LOGO (PLANO CON TEXTURA PNG TRANSPARENTE)
  // -------------------------------------------------
  const textureLoader = new THREE.TextureLoader();
  const logoTexture = textureLoader.load('PARALEL.png'); // asegúrate que exista
  const logoMaterial = new THREE.MeshBasicMaterial({ map: logoTexture, transparent: true });
  const logoMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), logoMaterial);
  logoMesh.position.set(0, 2, 0);
  scene.add(logoMesh);

  // -------------------------------------------------
  // CONFIG PANEL SCROLL
  // -------------------------------------------------
  // Datos: modelo GLB + texto
  const panelsData = [
    { model: 'EXP3.glb', text: 'Experiencia inmersiva' },
    { model: 'bus.glb', text: 'Contenido personalizable' },
    { model: 'eco.glb', text: 'Inversión sin riesgos' },
    { model: 'par2.glb', text: 'atrévete a ver el mundo virutal' }
  ];

  // Espaciado entre paneles en -Z
  const panelSpacing = 15;     // distancia entre paneles
  const firstPanelZ = -15;     // Z del primero
  const panelY = 2;            // altura base panel
  const panelSideOffset = 2;   // +/- X alternado para darle ángulo

  // Control de enfoque y animaciones
  const rotStartDist = 20;   // empezar rotación cuando la cámara está más cerca que esto
  const rotMaxSpeed  = 0.02; // rotación máxima
  const lookAtLerp   = 0.08; // suavidad cámara hacia panel activo
  const camZLerp     = 0.08; // suavidad mov. en Z (ya lo usabas)
  const textFadeDist = 45;   // distancia a partir de la cual texto = 0

  // Loader de modelos
  const loader = new GLTFLoader();

  // Almacenamos referencias a cada panel
  const panels = [];

  // Crea texto Canvas -> textura
  function makeTextTexture(str) {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 160;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 34px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(str, canvas.width / 2, canvas.height / 2);
    const tex = new THREE.CanvasTexture(canvas);
    return tex;
  }

  function createPanel(panelInfo, i) {
    const group = new THREE.Group();

    // Texto (canvas → textura → plano)
    const textTexture = makeTextTexture(panelInfo.text);
    const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, opacity: 0 });
    const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), textMaterial);
    textMesh.position.set(0, -1, 0);
    group.add(textMesh);

    // Modelo 3D
    loader.load(panelInfo.model, (gltf) => {
      const model = gltf.scene;
      model.scale.set(1.5, 1.5, 1.5);
      model.position.y = 0;
      model.userData.rotate = true; // bandera: se puede rotar cuando esté cerca
      group.add(model);
    });

    // Posición alternando a izquierda/derecha
    const side = i % 2 === 0 ? -panelSideOffset : panelSideOffset;
    group.position.set(side, panelY, firstPanelZ - i * panelSpacing);

    // Inclinación leve hacia la cámara central
    group.rotation.y = side < 0 ? Math.PI / 8 : -Math.PI / 8;

    scene.add(group);
    panels.push({ group, textMaterial });
  }

  panelsData.forEach(createPanel);

  // -------------------------------------------------
  // SCROLL → progreso lineal [0..1]
  // -------------------------------------------------
  let scrollProgress = 0;
  window.addEventListener('scroll', () => {
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    scrollProgress = maxScroll > 0 ? window.scrollY / maxScroll : 0;
  });

  // Rango total que recorre la cámara en Z
  const totalTravelZ = 100; // puedes ajustarlo; antes usabas ~100
  const camStartZ = 12;

  // Vector reutilizable para lerp de lookAt
  const camLookTarget = new THREE.Vector3();
  const currentLook = new THREE.Vector3(0, 2, 0); // arranque

  // -------------------------------------------------
  // ANIMACIÓN
  // -------------------------------------------------
  function animate() {
    requestAnimationFrame(animate);

    // Cámara avanza en Z según scroll
    const targetZ = camStartZ - scrollProgress * totalTravelZ;
    camera.position.z += (targetZ - camera.position.z) * camZLerp;

    // Determinar panel más cercano
    let closestPanel = null;
    let minDist = Infinity;
    panels.forEach(p => {
      const dz = camera.position.z - p.group.position.z;
      const dist = Math.abs(dz);
      if (dist < minDist) {
        minDist = dist;
        closestPanel = p;
      }
    });

  if (closestPanel) {
  const panelZ = closestPanel.group.position.z;

  if (camera.position.z > panelZ) {
    // Si la cámara está antes del panel → enfocar al panel
    camLookTarget.copy(closestPanel.group.position);
    camLookTarget.y += 0.5;
  } else {
    // Si la cámara ya pasó el panel → mirar hacia adelante
    camLookTarget.set(0, 2, -100); // punto fijo
  }

  currentLook.lerp(camLookTarget, lookAtLerp);
  camera.lookAt(currentLook);
}
    // Actualizar texto + rotaciones por distancia
    panels.forEach(p => {
      const dist = Math.abs(camera.position.z - p.group.position.z);

      // Texto: fade según distancia
      const opacity = THREE.MathUtils.clamp(1 - dist / textFadeDist, 0, 1);
      p.textMaterial.opacity = opacity;

      // Rotación: escala según cercanía
      const speedScale = THREE.MathUtils.clamp(1 - dist / rotStartDist, 0, 1);
      if (speedScale > 0) {
        p.group.children.forEach(child => {
          if (child.userData.rotate) child.rotation.y += rotMaxSpeed * speedScale;
        });
      }
    });

    renderer.render(scene, camera);
  }
  animate();

  // -------------------------------------------------
  // RESPONSIVE
  // -------------------------------------------------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
