<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"/>
  <title>PARALEL VR Realidad Virtual en Peru</title>

  <!-- SEO META -->
  <meta name="description" content="PARALEL VR: Alquiler de realidad virtual para eventos en Perú. Oculus / Meta Quest, experiencias inmersivas, activaciones BTL, contenido VR personalizado en Lima y todo el país.">
  <meta name="keywords" content="realidad virtual Perú, VR Perú, alquiler VR eventos, Oculus Perú, Meta Quest eventos, realidad virtual Lima, activaciones VR, realidad aumentada, simuladores VR, eventos tecnología">

  <link rel="icon" type="image/x-icon" href="favicon.ico">

  <style>
    :root {
      --scroll-height-mult: 3; /* multiplica altura de viewport x3 para scroll 3D */
    }

    body {
      margin: 0;
      background: #111;
      font-family: Arial, sans-serif;
    }

    /* Altura para scroll 3D inicial */
    html, body {
      height: calc(100vh * var(--scroll-height-mult));
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }
    canvas.webgl-fade {
      transition: opacity 0.8s ease;
    }

    /* HTML overlay que aparece al final */
    #html-wrapper {
      position: fixed;
      inset: 0;
      z-index: 1;
      display: none;   /* se habilita vía JS */
      opacity: 0;
      transition: opacity 0.8s ease;
      overflow-y: auto; /* scroll interno si el contenido crece */
    }

    /* RESET */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Inter', sans-serif;
}

body {
  background: #000;
  color: #fff;
}

/* HERO */
.hero {
  min-height: 100vh;
  background: radial-gradient(circle at right, rgba(0,120,255,0.15), transparent 60%),
              radial-gradient(circle at left, rgba(255,0,0,0.15), transparent 60%),
              #000;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 2rem;
}

.hero h1 {
  font-size: clamp(2rem, 5vw, 4rem);
  font-weight: 800;
  letter-spacing: 2px;
}

.hero h1 span {
  display: block;
}

.hero p {
  margin: 1.5rem 0 2rem;
  color: #bbb;
  max-width: 500px;
  margin-inline: auto;
}

.hero-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
  flex-wrap: wrap;
}

/* BOTONES */
.btn {
  padding: 0.9rem 1.8rem;
  text-decoration: none;
  font-weight: 600;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.btn.outline {
  border: 1px solid #fff;
  color: #fff;
}

.btn.outline:hover {
  background: #fff;
  color: #000;
}

.btn.gradient {
  background: linear-gradient(90deg, #ff0033, #007bff);
  color: #fff;
  box-shadow: 0 0 20px rgba(255,0,80,0.4);
}

.btn.gradient:hover {
  transform: translateY(-2px);
  box-shadow: 0 0 30px rgba(0,120,255,0.6);
}

/* SERVICIOS */
.services {
  padding: 5rem 2rem;
  text-align: center;
}

.services h2 {
  font-size: 2rem;
  margin-bottom: 3rem;
  letter-spacing: 1px;
}

.services-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 2rem;
  max-width: 1000px;
  margin: auto;
}

.service-card {
  background: linear-gradient(180deg, #0b0b0b, #000);
  border: 1px solid rgba(255,255,255,0.08);
  padding: 2.5rem 2rem;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.service-card:hover {
  transform: translateY(-6px);
  box-shadow: 0 0 25px rgba(255,0,80,0.25);
}

.service-card h3 {
  margin-bottom: 1rem;
}

.service-card p {
  color: #aaa;
}

/* CTA */
.cta {
  padding: 5rem 2rem;
  text-align: center;
  background: radial-gradient(circle, rgba(255,0,80,0.15), transparent 70%);
}

.cta h2 {
  margin-bottom: 2rem;
  font-size: 2rem;
}

.btn.big {
  font-size: 1.1rem;
  padding: 1rem 2.5rem;
}

/* MOBILE AJUSTES */
@media (max-width: 480px) {
  .hero h1 {
    letter-spacing: 1px;
  }

  .services {
    padding: 3rem 1.5rem;
  }

  .cta {
    padding: 3rem 1.5rem;
  }
}
/* === PARALELEPIPEDO PANELS === */
.paralelepipedo-panels {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 1.5rem;
  margin-bottom: 5rem;
}

.panel-img {
  position: relative;
  width: 200px;
  height: 200px;
  cursor: pointer;
  overflow: hidden;
  border-radius: 12px;
}

.panel-img img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 12px;
  transition: transform 0.3s ease;
}

.panel-img:hover img {
  transform: scale(1.1);
}

.overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  opacity: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  transition: opacity 0.3s ease;
  padding: 1rem;
  text-align: center;
}

.panel-img:hover .overlay {
  opacity: 1;
}

.overlay h3 {
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
}

.overlay p {
  font-size: 0.9rem;
  color: #ddd;
}

/* === CENTER + SIDE PANELS === */
.interactive-center {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

#central-trigger {
  width: 250px;
  height: auto;
  border-radius: 10px;
  box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
}

.side-panel {
  position: absolute;
  width: 160px;
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 1;
  transform: translateY(0);
  transition: all 0.3s ease;
}

.side-panel .box {
  background: #111;
  padding: 1rem;
  border-radius: 10px;
  font-weight: bold;
  margin-bottom: 0.5rem;
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
}

.side-panel p {
  font-size: 0.85rem;
  color: #ccc;
}

.side-panel.left {
  left: 5%;
  top: 50%;
  transform: translate(-100%, -50%);
}

.side-panel.right {
  right: 5%;
  top: 50%;
  transform: translate(100%, -50%);
}

@media (max-width: 768px) {
  .side-panel {
    position: static;
    transform: none;
    margin-top: 1rem;
  }

  .interactive-center {
    flex-direction: column;
    gap: 2rem;
  }
}
  </style>

  <!-- importmap opcional (cargas directas igualmente) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
/* ------------------ PRELOADER W/ ROTATING WIREFRAME CUBE ------------------ */

(() => {
  // --- crear DOM del preloader ---
  const pre = document.createElement('div');
  pre.id = 'preloader-overlay';
  pre.innerHTML = `
    <canvas id="preloader-canvas"></canvas>
    <div id="preloader-ui">
      <div id="preloader-cube-label">Cargando...</div>
      <div id="preloader-bar"><div id="preloader-bar-fill"></div></div>
    </div>
  `;
  document.body.appendChild(pre);

  // --- estilos dinámicos para evitar tocar <head> ---
  const style = document.createElement('style');
  style.textContent = `
    #preloader-canvas {
  width: 220px;
  height: 220px;
  display: block;
  margin: 0 auto;       /* Centra horizontalmente */
}
#preloader-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;  /* Centra también verticalmente */
  flex-direction: column;    /* Para colocar logo + canvas + barra en columna */
  background: #0b0b0b;
  z-index: 9999;
  transition: opacity 0.7s ease;
  opacity: 1;
}
    #preloader-ui {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8vh;
      width: 70%;
      max-width: 520px;
      text-align: center;
      pointer-events: none;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    #preloader-cube-label { margin-bottom: 10px; opacity: 0.95; font-weight: 600; }
    #preloader-bar {
      height: 8px;
      background: rgba(255,255,255,0.12);
      border-radius: 8px;
      overflow: hidden;
    }
    #preloader-bar-fill {
      width: 0%;
      height: 100%;
      background: rgba(255,255,255,1);
      transition: width 0.2s linear;
    }
  `;
  document.head.appendChild(style);

  // --- THREE renderer for preloader cube (isolation to avoid conflicts) ---
  const canvas = document.getElementById('preloader-canvas');
  const preRenderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  preRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  preRenderer.setSize(220, 220);

  // escena pequeña
  const preScene = new THREE.Scene();
  const preCam = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
  preCam.position.set(0, 0, 3);
  preScene.add(new THREE.AmbientLight(0xffffff, 0.9));

  // wireframe cube (aristas)
  const box = new THREE.BoxGeometry(1.2, 1.2, 1.2);
  // líneas de aristas
  const edges = new THREE.EdgesGeometry(box);
  const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
  const wire = new THREE.LineSegments(edges, lineMat);
  preScene.add(wire);

  // animación simple
  let preAnim = true;
  function prerender() {
    if (!preAnim) return;
    requestAnimationFrame(prerender);
    const t = performance.now() * 0.001;
    wire.rotation.x = t * 0.6;
    wire.rotation.y = t * 0.9;
    preRenderer.render(preScene, preCam);
  }
  prerender();

  // --- LoadingManager para sincronizar cargas (se usará en tu módulo) ---
  const loadingBarFill = document.getElementById('preloader-bar-fill');
  const manager = new THREE.LoadingManager();
  let itemsTotal = 0;
  manager.onStart = function (url, itemsLoaded, itemsTotalArg) {
    itemsTotal = itemsTotalArg || itemsTotal;
    // console.log('onStart', url, itemsLoaded, itemsTotalArg);
  };
  manager.onProgress = function (url, itemsLoaded, itemsTotalArg) {
    itemsTotal = itemsTotalArg || itemsTotal;
    const pct = itemsTotal > 0 ? (itemsLoaded / itemsTotal) * 100 : 100;
    loadingBarFill.style.width = pct.toFixed(2) + '%';
  };
  manager.onLoad = function () {
    // fade out overlay
    pre.style.opacity = '0';
    setTimeout(() => {
      preAnim = false;
      pre.remove();
      style.remove();
    }, 700);
  };
  // Exponer manager y helper globalmente dentro del closure para que puedas usarlo
  window.__PARALEL_PRELOADER = { manager, updateProgress: (p)=>{ loadingBarFill.style.width = p+'%'; } };
})();
  // ---------------- CONFIG GLOBALES ----------------
  const panelSpacing   = 15;  // distancia entre paneles
  const firstPanelZ    = -15; // Z panel #1
  const panelY         = 2;   // altura panel
  const panelSideOffset= 2;   // alterna izquierda/derecha
  const rotStartDist   = 20;  // dist rotación
  const rotMaxSpeed    = 0.02;
  const camZLerp       = 0.08;
  const lookAtLerp     = 0.08;
  const textFadeDist   = 45;
  const approachStart  = 45;  // empieza a mirar panel
  const approachEnd    = 5;   // deja de mirar panel y vuelve al frente
  const fadeStartPercent = 80; // empieza fade de 3D
  const fadeEndPercent   = 85; // termina fade
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  const clock = new THREE.Clock();
  const mixers = [];

  // ---------------- ESCENA ----------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    500
  );
  const camStartZ = 12;
  camera.position.set(0, 2, camStartZ);
  camera.lookAt(0, 2, 0);

  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  light.position.set(0, 10, 0);
  scene.add(light);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.classList.add('webgl-fade');
  document.body.appendChild(renderer.domElement);

  const borderMaterial = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.8
  });

  // ---------------- GRID Piso/Techo ----------------
  const gridOpacity = 0.15;
  const gridSize = 500;
  const gridDivs = 100;

  const gridFloor = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridFloor.material.opacity = gridOpacity;
  gridFloor.material.transparent = true;
  scene.add(gridFloor);

  const gridCeiling = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridCeiling.material.opacity = gridOpacity;
  gridCeiling.material.transparent = true;
  gridCeiling.position.y = 4;
  gridCeiling.rotation.x = Math.PI;
  scene.add(gridCeiling);

  // ---------------- LOGO central ----------------
  const loadingManager = window.__PARALEL_PRELOADER ? window.__PARALEL_PRELOADER.manager : new THREE.LoadingManager();
  const textureLoader = new THREE.TextureLoader(loadingManager);
  const logoTexture = textureLoader.load('PARALEL2.png');
  const logoMaterial = new THREE.MeshBasicMaterial({ map: logoTexture, transparent: true });
  const logoMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), logoMaterial);
  logoMesh.position.set(0, 2, 0);
  scene.add(logoMesh);

  // ---------------- DATA DE PANELES ----------------
  const panelsData = [
    { model: 'EXP3.glb', text: 'Realidad virtual, Competitivo e Inmersivo' },
    { model: 'AR.glb', text: 'Realidad Aumentada para interacciones' },
    { model: 'Taca.glb', text: 'Juegos táctiles' },
    { model: 'par3.glb', text: 'Tecnología del entretenimiento' }
  ];

  const loader = new GLTFLoader(loadingManager);
  const panels = [];

  // ---- crea textura canvas con wrap + fondo
 function makeTextTexture(str) {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 160;
  const ctx = canvas.getContext('2d');

  // Fondo negro con borde blanco
  const padding = 8;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Borde blanco
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 4; // grosor del borde
  ctx.strokeRect(0, 0, canvas.width, canvas.height);

  // Texto blanco centrado
  let fontSize = 44;
  ctx.font = `bold ${fontSize}px Arial`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Wrap text
  function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  }

  const lineHeight = fontSize + 10;
  const startY = canvas.height / 2 - lineHeight / 2;
  wrapText(str, canvas.width / 2, startY, canvas.width - 40, lineHeight);

  return new THREE.CanvasTexture(canvas);
}

  function createPanel(panelInfo, i) {
  const group = new THREE.Group();

  // Texto
  const textTexture = makeTextTexture(panelInfo.text);
  const textMaterial = new THREE.MeshBasicMaterial({
    map: textTexture,
    transparent: true,
    opacity: 0
  });
  textMaterial.baseOpacity = 1;

  // Borde luminoso
  const borderMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8
  });
  const borderMesh = new THREE.Mesh(new THREE.PlaneGeometry(4.1, 1.1), borderMaterial);
  borderMesh.position.set(0, -1, -0.01);
  group.add(borderMesh);

  // (Opcional) Halo suave
  const haloMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.2
  });
  const haloMesh = new THREE.Mesh(new THREE.PlaneGeometry(4.3, 1.3), haloMaterial);
  haloMesh.position.set(0, -1, -0.02);
  group.add(haloMesh);

  // Texto principal
  const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), textMaterial);
  textMesh.position.set(0, -1, 0);
  group.add(textMesh);

  // Modelo con animaciones
  loader.load(panelInfo.model, (gltf) => {
    const model = gltf.scene;
    model.scale.set(1.5, 1.5, 1.5);
    model.position.y = 0;
    model.userData.rotate = true;

    // Si hay animaciones, guardamos mixer y clip
    if (gltf.animations && gltf.animations.length > 0) {
      const mixer = new THREE.AnimationMixer(model);
      const action = mixer.clipAction(gltf.animations[0]); // primera animación
      model.userData.mixer = mixer;
      model.userData.action = action;
    }

    group.add(model); //error acutal 
});
  // Posición alternada
  const side = i % 2 === 0 ? -panelSideOffset : panelSideOffset;
  group.position.set(side, panelY, firstPanelZ - i * panelSpacing);
  group.rotation.y = side < 0 ? Math.PI / 8 : -Math.PI / 8;

  scene.add(group);
  panels.push({ group, textMaterial });
}
  panelsData.forEach(createPanel);
// ---------------- TEXTO debajo del logo ----------------

// Crear un canvas para dibujar el texto
const textCanvas = document.createElement("canvas");
textCanvas.width = 1024;
textCanvas.height = 256;

const ctx = textCanvas.getContext("2d");
ctx.fillStyle = "rgba(255, 255, 255, 1)";
ctx.font = "80px Arial";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillText("Empieza a bajar ↓", textCanvas.width / 2, textCanvas.height / 2);

// Convertir a textura de Three.js
const textTexture = new THREE.CanvasTexture(textCanvas);
textTexture.needsUpdate = true;

const textMaterial = new THREE.MeshBasicMaterial({
  map: textTexture,
  transparent: true
});

// Ajusta estas medidas para que combine con el tamaño de tu logo
const textMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 2), // ancho, alto
  textMaterial
);

// Posición debajo del logo
textMesh.position.set(0, -1.4, 0); 
scene.add(textMesh);
  // ---------------- TEXTO final de los paneles ----------------

// Canvas para texto final
const endTextCanvas = document.createElement("canvas");
endTextCanvas.width = 1024;
endTextCanvas.height = 256;

const endCtx = endTextCanvas.getContext("2d");
endCtx.fillStyle = "rgba(255, 255, 255, 1)";
endCtx.font = "80px Arial";
endCtx.textAlign = "center";
endCtx.textBaseline = "middle";
endCtx.fillText("Sigue bajando ↓", endTextCanvas.width / 2, endTextCanvas.height / 2);

const endTextTexture = new THREE.CanvasTexture(endTextCanvas);
endTextTexture.needsUpdate = true;

const endTextMaterial = new THREE.MeshBasicMaterial({
  map: endTextTexture,
  transparent: true
});

// Ajusta el tamaño igual que el texto inicial
const endTextMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(12, 2.5),
  endTextMaterial
);

// <<< IMPORTANTE >>>  
// Aquí colocamos el texto al FINAL del pasillo.
// Si tus paneles están distribuidos con z += 30 aproximadamente,
// esto lo coloca justo al terminar todo.

const totalPanels = panelsData.length;
const spacing = 30;  // Ajusta este valor si tu pasillo usa otro espaciado
const finalZ = - (totalPanels * 17); // aparece un poco después del último panel

endTextMesh.position.set(0, 3, finalZ);
scene.add(endTextMesh);
  
  // ---------------- SCROLL PROGRESS ----------------
  let scrollProgress = 0;
  window.addEventListener('scroll', () => {
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    scrollProgress = maxScroll > 0 ? window.scrollY / maxScroll : 0;
  });

  // ---------------- FADE GLOBAL CONTROL ----------------
  let globalFade = 1;   // 1=visible 3D, 0=oculto
  let animating = true; // para pausar render cuando está oculto

  function pause3D() { animating = false; }
  function resume3D() { 
    if (!animating) {
      animating = true;
      animate(); 
    }
  }

  // ---------------- ANIMATE LOOP ----------------
  function animate() {
    if (!animating) return;
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    mixers.forEach(m => m.update(delta));
    // Cámara avanza en Z según scroll
    const totalTravelZ = 100; // puedes ajustar
    const targetZ = camStartZ - scrollProgress * totalTravelZ;
    camera.position.z += (targetZ - camera.position.z) * camZLerp;

    // Determinar panel más cercano (para enfoque)
    let closestPanel = null;
    let minDist = Infinity;
    panels.forEach(p => {
      const dz = camera.position.z - p.group.position.z;
      const dist = Math.abs(dz);
      if (dist < minDist) {
        minDist = dist;
        closestPanel = p;
      }
    if (p.group.userData.mixer) {
        p.group.userData.mixer.update(delta);
      }
    });

    // Enfoque asimétrico (approachStart -> approachEnd -> al frente)
    const forwardLook = new THREE.Vector3(0, 2, -100);
    if (closestPanel) {
      const panelZ = closestPanel.group.position.z;
      const dz = camera.position.z - panelZ; // + = antes del panel
      let weight = 0;

      if (dz > approachEnd && dz < approachStart) {
        weight = THREE.MathUtils.clamp(
          (dz - approachEnd) / (approachStart - approachEnd),
          0, 1
        );
      } else if (dz <= approachEnd) {
        weight = 0;
      } else if (dz >= approachStart) {
        weight = 0; // todavía lejos, mira al frente
      }

      // Mezcla panel vs adelante
      const camLookTarget = forwardLook.clone().lerp(closestPanel.group.position, weight);
      camLookTarget.y += 0.5;
      currentLook.lerp(camLookTarget, lookAtLerp);
      camera.lookAt(currentLook);
    }

    // Actualizar opacidades + rotación por distancia * fade global
    panels.forEach(p => {
      const dist = Math.abs(camera.position.z - p.group.position.z);
      const distOpacity = THREE.MathUtils.clamp(1 - dist / textFadeDist, 0, 1);
      p.textMaterial.opacity = distOpacity * p.textMaterial.baseOpacity * globalFade;

      // Rotación al acercarse
      const speedScale = THREE.MathUtils.clamp(1 - dist / rotStartDist, 0, 1);
      if (speedScale > 0 && globalFade > 0.01) {
        p.group.children.forEach(child => {
          if (child.userData.rotate) child.rotation.y += rotMaxSpeed * speedScale;
        });
      }
    });

    // Fade grid/materials
    gridFloor.material.opacity   = gridOpacity * globalFade;
    gridCeiling.material.opacity = gridOpacity * globalFade;
    logoMaterial.opacity         = globalFade;

    renderer.render(scene, camera);
  }
  const currentLook = new THREE.Vector3(0, 2, 0); // after animate defined
  animate();

  // ---------------- TRANSICIÓN 3D -> HTML ----------------
  const htmlWrapper = document.getElementById('html-wrapper');
  const htmlSection = document.getElementById('html-section');
  const canvas = renderer.domElement;

  function checkScrollTransition() {
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    const scrollPercent = maxScroll > 0 ? (window.scrollY / maxScroll) * 100 : 0;

    // t: 0..1 entre fadeStartPercent y fadeEndPercent
    let t = (scrollPercent - fadeStartPercent) / (fadeEndPercent - fadeStartPercent);
    t = Math.min(Math.max(t, 0), 1);

    globalFade = 1 - t; // usado en animate()

    // Canvas CSS fade
    canvas.style.opacity = globalFade.toString();

    if (t >= 1 && htmlWrapper.style.display !== 'block') {
      htmlWrapper.style.display = 'block';
      requestAnimationFrame(() => htmlWrapper.style.opacity = '1');
      pause3D();
    } else if (t < 1 && htmlWrapper.style.display === 'block') {
      htmlWrapper.style.opacity = '0';
      // pequeño timeout para ocultar tras transición
      setTimeout(() => {
        if (globalFade < 1) return; // evita ocultar si volvió a bajar
        htmlWrapper.style.display = 'none';
      }, 800);
      resume3D();
    }
  }
  window.addEventListener('scroll', checkScrollTransition);

  // ---------------- RESPONSIVE ----------------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
window.addEventListener('click', (event) => {
  // Normalizar coordenadas de mouse
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Lanzar raycaster
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children, true); // true = busca en hijos

  if (intersects.length > 0) {
    const clicked = intersects[0].object;
    const root = clicked.parent; // subimos al modelo
    if (root.userData.mixer && root.userData.action) {
      root.userData.action.reset().play(); // reproducir desde inicio
    }
  }
  });
</script>

<!-- HTML overlay final -->
<div id="html-wrapper">
  <section class="hero">
    <div class="hero-content">
      <h1>LLEVAMOS TU EVENTO<br><span>A OTRA DIMENSIÓN</span></h1>
      <p>Tecnología de entretenimiento de vanguardia</p>

      <div class="hero-buttons">
        <a href="#" class="btn outline">Experiencias VR</a>
        <a href="#" class="btn gradient">Realidad Aumentada</a>
      </div>
    </div>
  </section>

  <!-- SERVICIOS -->
  <section class="services">
    <h2>INMERSIÓN SIN LÍMITES</h2>

    <div class="services-grid">
      <div class="service-card">
        <h3>Juegos de Realidad Virtual</h3>
        <p>Vive la emoción del mundo virtual</p>
      </div>

      <div class="service-card">
        <h3>Experiencias de Realidad Aumentada</h3>
        <p>Innovación interactiva en el mundo real</p>
      </div>
    </div>
  </section>

  <!-- CTA -->
  <section class="cta">
    <h2>¿LISTO PARA VIVIR LA EXPERIENCIA?</h2>
    <a href="#" class="btn gradient big">Contáctanos</a>
  </section>
</div>
</body>
  <script>
  // Paneles tipo paralelepípedo
  const panels = document.querySelectorAll('.panel');
  const infoBox = document.getElementById('panel-info');
  const titleBox = document.getElementById('panel-title');
  const textBox = document.getElementById('panel-description');

  panels.forEach(panel => {
    panel.addEventListener('click', () => {
      titleBox.textContent = panel.dataset.title;
      textBox.textContent = panel.dataset.text;
      infoBox.classList.remove('hidden');
    });
  });

  function closePanel() {
    infoBox.classList.add('hidden');
  }

  // Paneles que se revelan desde la imagen central
  const triggerImage = document.getElementById('trigger-image');
  const explosivePanels = document.querySelectorAll('.exploding-panel');

  triggerImage.addEventListener('click', () => {
    explosivePanels.forEach((panel, i) => {
      panel.classList.toggle('active');
    });
  });

  explosivePanels.forEach(panel => {
    panel.addEventListener('click', () => {
      alert(`${panel.dataset.title}\n${panel.dataset.text}`);
    });
  });
</script>
</html>
