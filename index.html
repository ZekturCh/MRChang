<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PARALEL VR</title>
  <style>
    body { margin: 0; background: #111; }
    html, body { height: 300vh; }
    canvas { display: block; position: fixed; top: 0; left: 0; }

  #html-section {
    display: none;
    background: #fff;
    color: #111;
    padding: 50px;
    text-align: center;
    font-family: Arial, sans-serif;
  }
  </style>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
  }
}
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

  // -------------------------------------------------
  // ESCENA BÁSICA
  // -------------------------------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111); // gris muy oscuro, no negro puro

  // Cámara: más largo far plane porque viajamos bastante en -Z
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
  camera.position.set(0, 2, 12); // arranque
  camera.lookAt(0, 2, 0);

  // Luz suave hemisférica (no crítica, pero ayuda a GLBs con materiales)
  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  light.position.set(0, 10, 0);
  scene.add(light);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // -------------------------------------------------
  // PISO Y TECHO CUADRICULADOS
  // -------------------------------------------------
  const gridOpacity = 0.15;
  const gridSize = 500;
  const gridDivs = 100;

  const gridFloor = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridFloor.material.opacity = gridOpacity;
  gridFloor.material.transparent = true;
  scene.add(gridFloor);

  const gridCeiling = new THREE.GridHelper(gridSize, gridDivs, 0xffffff, 0xffffff);
  gridCeiling.material.opacity = gridOpacity;
  gridCeiling.material.transparent = true;
  gridCeiling.position.y = 4;        // altura del “techo”
  gridCeiling.rotation.x = Math.PI;  // voltear para que la cara visible mire hacia abajo
  scene.add(gridCeiling);

  // -------------------------------------------------
  // LOGO (PLANO CON TEXTURA PNG TRANSPARENTE)
  // -------------------------------------------------
  const textureLoader = new THREE.TextureLoader();
  const logoTexture = textureLoader.load('PARALEL2.png'); // asegúrate que exista
  const logoMaterial = new THREE.MeshBasicMaterial({ map: logoTexture, transparent: true });
  const logoMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), logoMaterial);
  logoMesh.position.set(0, 2, 0);
  scene.add(logoMesh);

  // -------------------------------------------------
  // CONFIG PANEL SCROLL
  // -------------------------------------------------
  // Datos: modelo GLB + texto
  const panelsData = [
    { model: 'EXP3.glb', text: 'Experiencia inmersiva' },
    { model: 'bus2.glb', text: 'Contenido personalizable' },
    { model: 'eco2.glb', text: 'Inversión a tu presupuesto' },
    { model: 'par2.glb', text: 'Entra al mundo paralelo' }
  ];

  // Espaciado entre paneles en -Z
  const panelSpacing = 15;     // distancia entre paneles
  const firstPanelZ = -15;     // Z del primero
  const panelY = 2;            // altura base panel
  const panelSideOffset = 2;   // +/- X alternado para darle ángulo

  // Control de enfoque y animaciones
  const rotStartDist = 20;   // empezar rotación cuando la cámara está más cerca que esto
  const rotMaxSpeed  = 0.02; // rotación máxima
  const lookAtLerp   = 0.08; // suavidad cámara hacia panel activo
  const camZLerp     = 0.08; // suavidad mov. en Z (ya lo usabas)
  const textFadeDist = 45;   // distancia a partir de la cual texto = 0

  // Loader de modelos
  const loader = new GLTFLoader();

  // Almacenamos referencias a cada panel
  const panels = [];

 // Crea texto Canvas -> textura con ajuste dinámico y fondo
function makeTextTexture(str) {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 160;
  const ctx = canvas.getContext('2d');

  // Fondo negro semitransparente
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Ajuste de tamaño base
  let fontSize = 44;
  ctx.font = `bold ${fontSize}px Arial`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';

  // Función para dividir texto
  function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  }

  // Centrado vertical básico
  const lineHeight = fontSize + 10;
  const startY = canvas.height / 2 - lineHeight / 2;

  wrapText(str, canvas.width / 2, startY, canvas.width - 40, lineHeight);

  return new THREE.CanvasTexture(canvas);
}

  function createPanel(panelInfo, i) {
    const group = new THREE.Group();

    // Texto (canvas → textura → plano)
    const textTexture = makeTextTexture(panelInfo.text);
    const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, opacity: 0 });
    const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), textMaterial);
    textMesh.position.set(0, -1, 0);
    group.add(textMesh);

    // Modelo 3D
    loader.load(panelInfo.model, (gltf) => {
      const model = gltf.scene;
      model.scale.set(1.5, 1.5, 1.5);
      model.position.y = 0;
      model.userData.rotate = true; // bandera: se puede rotar cuando esté cerca
      group.add(model);
    });

    // Posición alternando a izquierda/derecha
    const side = i % 2 === 0 ? -panelSideOffset : panelSideOffset;
    group.position.set(side, panelY, firstPanelZ - i * panelSpacing);

    // Inclinación leve hacia la cámara central
    group.rotation.y = side < 0 ? Math.PI / 8 : -Math.PI / 8;

    scene.add(group);
    panels.push({ group, textMaterial });
  }

  panelsData.forEach(createPanel);

  // -------------------------------------------------
  // SCROLL → progreso lineal [0..1]
  // -------------------------------------------------
  let scrollProgress = 0;
  window.addEventListener('scroll', () => {
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    scrollProgress = maxScroll > 0 ? window.scrollY / maxScroll : 0;
  });

  // Rango total que recorre la cámara en Z
  const totalTravelZ = 100; // puedes ajustarlo; antes usabas ~100
  const camStartZ = 12;

  // Vector reutilizable para lerp de lookAt
  const camLookTarget = new THREE.Vector3();
  const currentLook = new THREE.Vector3(0, 2, 0); // arranque

  // -------------------------------------------------
  // ANIMACIÓN
  // -------------------------------------------------
  function animate() {
    requestAnimationFrame(animate);

    // Cámara avanza en Z según scroll
    const targetZ = camStartZ - scrollProgress * totalTravelZ;
    camera.position.z += (targetZ - camera.position.z) * camZLerp;

    // Determinar panel más cercano
    let closestPanel = null;
    let minDist = Infinity;
    panels.forEach(p => {
      const dz = camera.position.z - p.group.position.z;
      const dist = Math.abs(dz);
      if (dist < minDist) {
        minDist = dist;
        closestPanel = p;
      }
    });

const approachStart = 45;  // Empieza a mirar el panel desde esta distancia
const approachEnd = 5;     // Deja de mirar el panel cuando llega a esta distancia
const forwardLook = new THREE.Vector3(0, 2, -100);

if (closestPanel) {
  const panelZ = closestPanel.group.position.z;
  const dz = camera.position.z - panelZ; // Distancia cámara - panel

  let weight = 0; // 0 = mirar al frente, 1 = mirar al panel

  if (dz > approachEnd && dz < approachStart) {
    // Dentro del rango [approachStart → approachEnd]
    weight = THREE.MathUtils.clamp((dz - approachEnd) / (approachStart - approachEnd), 0, 1);
  } else if (dz <= approachEnd) {
    // Ya está muy cerca o lo pasó → mirar al frente
    weight = 0;
  }

  // Mezclar objetivo: panel vs adelante
  camLookTarget.copy(forwardLook).lerp(closestPanel.group.position, weight);
  camLookTarget.y += 0.5;

  currentLook.lerp(camLookTarget, lookAtLerp);
  camera.lookAt(currentLook);
}
    // Actualizar texto + rotaciones por distancia
    panels.forEach(p => {
      const dist = Math.abs(camera.position.z - p.group.position.z);

      // Texto: fade según distancia
      const opacity = THREE.MathUtils.clamp(1 - dist / textFadeDist, 0, 1);
      p.textMaterial.opacity = opacity;

      // Rotación: escala según cercanía
      const speedScale = THREE.MathUtils.clamp(1 - dist / rotStartDist, 0, 1);
      if (speedScale > 0) {
        p.group.children.forEach(child => {
          if (child.userData.rotate) child.rotation.y += rotMaxSpeed * speedScale;
        });
      }
    });

    renderer.render(scene, camera);
  }
  animate();
  // Referencias
const htmlSection = document.getElementById('html-section');
const canvas = renderer.domElement;

// Mostrar/Ocultar según scroll
function checkScrollTransition() {
  const maxScroll = document.body.scrollHeight - window.innerHeight;
  const scrollPercent = maxScroll > 0 ? (window.scrollY / maxScroll) * 100 : 0;

  if (scrollPercent > 95) {
    // Llegó al final: ocultar canvas y mostrar HTML
    canvas.style.display = 'none';
    htmlSection.style.display = 'block';
  } else {
    // Aún en la parte 3D: mostrar canvas, ocultar HTML
    canvas.style.display = 'block';
    htmlSection.style.display = 'none';
  }
}

window.addEventListener('scroll', checkScrollTransition);

  // -------------------------------------------------
  // RESPONSIVE
  // -------------------------------------------------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
<div id="html-section">
  <h1>Bienvenido a la siguiente sección</h1>
  <p>Aquí puedes poner contenido normal: texto, imágenes, botones...</p>
  <button onclick="alert('¡Click!')">Haz click</button>
</div>
</body>
</html>
